<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>산불 확산 시뮬레이터 - 이펙트 개수 줄임</title>
  <style>
    body { font-family: sans-serif; }
    canvas { border: 1px solid #888; background-color: #f0f8ff; display: block; }
    #controls { margin: 10px 0; }
  </style>
</head>
<body>
  <h2>🔥 산불 확산 시뮬레이터 (4방향 확산)</h2>

  <div id="controls">
    <label>🌬️ 바람 방향:
      <select id="windDir">
        <option value="none">없음</option>
        <option value="right">→ 오른쪽</option>
        <option value="left">← 왼쪽</option>
        <option value="up">↑ 위쪽</option>
        <option value="down">↓ 아래쪽</option>
      </select>
    </label>

    <label>💧 습도:
      <input type="range" id="humidity" min="0" max="1" step="0.1" value="0.3">
      <span id="humidityVal">0.3</span>
    </label>

    <button onclick="ignite()">🔥 점화 시작</button>
    <button onclick="reset()">🔄 초기화</button>
  </div>

  <img id="terrainImg" src="terrain.JPEG" style="display:none;" crossorigin="anonymous">
  <canvas id="canvas" width="1000" height="700"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const terrainImg = document.getElementById("terrainImg");

    let wind = { direction: "none", effect: 0.5 };
    let humidity = 0.3;
    let trees = [];
    let fireballs = [];

    class Tree {
      constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.id = id;
        this.burned = false;
        this.onFire = false;
      }

      draw() {
        ctx.beginPath();
        if (this.burned) ctx.fillStyle = "gray";
        else if (this.onFire) ctx.fillStyle = "red";
        else ctx.fillStyle = "green";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Fireball {
      constructor(x, y, dx, dy, speed = 2) {
        const windFactor = getWindFactor(dx, dy);
        this.dx = dx * speed * windFactor;
        this.dy = dy * speed * windFactor;
        this.x = x;
        this.y = y;
        this.radius = 5;
        this.active = true;
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;
      }

      draw() {
        ctx.beginPath();
        ctx.fillStyle = "orange";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function getWindFactor(dx, dy) {
      if (wind.direction === "right" && dx > 0) return 1 + wind.effect;
      if (wind.direction === "left" && dx < 0) return 1 + wind.effect;
      if (wind.direction === "down" && dy > 0) return 1 + wind.effect;
      if (wind.direction === "up" && dy < 0) return 1 + wind.effect;
      return 1;
    }

    function detectCollision(ball, tree) {
      const dx = ball.x - tree.x;
      const dy = ball.y - tree.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      return dist < ball.radius + tree.radius;
    }

    function spreadFrom(tree) {
      if (tree.burned) return;
      tree.onFire = false;
      tree.burned = true;

      // 🔥 여기만 변경: 4방향 확산
      const directions = [
        [1, 0], [-1, 0], [0, 1], [0, -1]
      ];

      for (let [dx, dy] of directions) {
        fireballs.push(new Fireball(tree.x, tree.y, dx, dy));
      }
    }

    function ignite() {
      const startTree = trees[Math.floor(Math.random() * trees.length)];
      startTree.onFire = true;
      spreadFrom(startTree);
    }

    function update() {
      for (let ball of fireballs) {
        if (!ball.active) continue;
        ball.update();

        for (let tree of trees) {
          if (!tree.burned && detectCollision(ball, tree)) {
            ball.active = false;
            tree.onFire = true;
            const delay = 300 + humidity * 700;
            setTimeout(() => spreadFrom(tree), delay);
            break;
          }
        }
      }

      fireballs = fireballs.filter(b => b.active &&
        b.x >= 0 && b.x <= canvas.width && b.y >= 0 && b.y <= canvas.height);
    }

    function draw() {
      ctx.drawImage(terrainImg, 0, 0, canvas.width, canvas.height);
      for (let tree of trees) tree.draw();
      for (let ball of fireballs) ball.draw();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function reset() {
      trees = [];
      fireballs = [];
      plantTreesFromImage();
    }

    function plantTreesFromImage() {
      const hidden = document.createElement("canvas");
      hidden.width = terrainImg.width;
      hidden.height = terrainImg.height;
      const hctx = hidden.getContext("2d");
      hctx.drawImage(terrainImg, 0, 0);
      const imgData = hctx.getImageData(0, 0, hidden.width, hidden.height).data;

      for (let i = 0; i < 600; i++) {
        const x = Math.floor(Math.random() * canvas.width);
        const y = Math.floor(Math.random() * canvas.height);
        const pixelX = Math.floor(x * (terrainImg.width / canvas.width));
        const pixelY = Math.floor(y * (terrainImg.height / canvas.height));
        const idx = (pixelY * terrainImg.width + pixelX) * 4;
        const r = imgData[idx];
        const g = imgData[idx + 1];
        const b = imgData[idx + 2];
        if (g > 100 && g > r && g > b) {
          trees.push(new Tree(x, y, trees.length));
        }
      }
    }

    // UI 연결
    document.getElementById("windDir").addEventListener("change", e => {
      wind.direction = e.target.value;
    });

    document.getElementById("humidity").addEventListener("input", e => {
      humidity = parseFloat(e.target.value);
      document.getElementById("humidityVal").innerText = humidity.toFixed(1);
    });

    terrainImg.onload = () => {
      reset();
      loop();
    };
  </script>
</body>
</html>
