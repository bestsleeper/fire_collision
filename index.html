<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>산불 확산 시뮬레이션 (픽셀화된 위성사진)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      font-family: sans-serif;
    }
    #sidebar {
      width: 250px;
      border-right: 1px solid #ccc;
      padding: 20px;
      box-sizing: border-box;
    }
    #sidebar h2 { margin-top: 0; }
    .control-group { margin: 20px 0; }
    label { display: block; margin-bottom: 5px; font-weight: bold; }
    #compass {
      width: 200px; height: 200px;
      border: 1px solid #000; border-radius:50%;
      cursor: crosshair; margin-bottom: 20px;
    }
    #humidity-slider { transform: rotate(-90deg); width:150px; margin-top:10px; }
    button { padding:5px 10px; margin-right:10px; }
    #main {
      flex:1; position:relative;
      background:#000;
    }
    #canvas {
      display:block; width:100%; height:100%;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>풍향 설정</h2>
    <canvas id="compass" width="200" height="200"></canvas>

    <div class="control-group">
      <label for="windSpeed">풍속</label>
      <input type="range" id="windSpeed" min="0" max="1" step="0.1" value="0.5">
      <span id="windSpeedVal">0.5</span>
    </div>

    <div class="control-group">
      <label for="humidity-slider">습도</label>
      <input type="range" id="humidity-slider" min="0" max="1" step="0.1" value="0.3">
      <span id="humVal">0.3</span>
    </div>

    <div class="control-group">
      <button id="ignite">🔥 점화</button>
      <button id="reset">🔄 초기화</button>
    </div>
  </div>

  <div id="main">
    <canvas id="canvas"></canvas>
  </div>

  <script>
  // -------------------
  // 전역 변수
  // -------------------
  const EMPTY=0, TREE=1, BURNING=2, BURNED=3;
  let grid=[], cols, rows;
  let windDir={x:0,y:-1}, windSpeed=0.5, humidity=0.3;

  const canvas=document.getElementById('canvas');
  const ctx=canvas.getContext('2d');

  // 픽셀화용 오프스크린 캔버스
  const offCanvas=document.createElement('canvas');
  const offCtx=offCanvas.getContext('2d');
  const mapImg=new Image();
  mapImg.src='firebackground.jpg';

  // 픽셀 단위 크기 (예: 10px 블록)
  const pixelSize=10;

  // -------------------
  // 초기화
  // -------------------
  mapImg.onload=()=>{
    cols = Math.floor(mapImg.width / pixelSize);
    rows = Math.floor(mapImg.height / pixelSize);
    canvas.width = mapImg.width;
    canvas.height = mapImg.height;
    offCanvas.width = cols;
    offCanvas.height = rows;

    // 그리드 설정
    grid = Array.from({ length: rows }, () => Array(cols).fill(EMPTY));

    // 나무(초록) 픽셀 탐지
    offCtx.drawImage(mapImg, 0, 0, cols, rows);
    const data = offCtx.getImageData(0, 0, cols, rows).data;
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        const idx = (y*cols + x)*4;
        const r=data[idx], g=data[idx+1], b=data[idx+2];
        if(g>r && g>b) grid[y][x]=TREE;
      }
    }

    // 시뮬레이션 시작
    loop();
  };

  // -------------------
  // 시뮬레이션 로직
  // -------------------
  function ignite(){
    // 그리드 단위 랜덤 점화
    for(let i=0;i<1000;i++){
      const x=Math.floor(Math.random()*cols);
      const y=Math.floor(Math.random()*rows);
      if(grid[y][x]===TREE){ grid[y][x]=BURNING; break; }
    }
  }

  function spreadFire(){
    const burning=[];
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        if(grid[y][x]===BURNING) burning.push({x,y});
      }
    }
    burning.forEach(cell=>{
      grid[cell.y][cell.x]=BURNED;
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>{
        const nx=cell.x+d[0], ny=cell.y+d[1];
        if(nx>=0&&nx<cols&&ny>=0&&ny<rows&&grid[ny][nx]===TREE){
          const factor=1+windSpeed*(d[0]*windDir.x + d[1]*windDir.y);
          const delay=(300+humidity*700)/factor;
          setTimeout(()=> grid[ny][nx]=BURNING, delay);
        }
      });
    });
  }

  // -------------------
  // 렌더링
  // -------------------
  function draw(){
    // 배경: 픽셀화된 사진
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const px=offCtx.getImageData(x,y,1,1).data;
        ctx.fillStyle=`rgba(${px[0]},${px[1]},${px[2]},1)`;
        ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
      }
    }
    // 불 상태 그리기(투명 블렌딩)
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const state=grid[y][x];
        if(state===TREE){ ctx.fillStyle='rgba(0,255,0,0.3)'; }
        else if(state===BURNING){ ctx.fillStyle='rgba(255,0,0,0.7)'; }
        else if(state===BURNED){ ctx.fillStyle='rgba(128,128,128,0.5)'; }
        else continue;
        ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
      }
    }
  }

  function loop(){
    spreadFire();
    draw();
    requestAnimationFrame(loop);
  }

  // -------------------
  // UI 이벤트
  // -------------------
  const compass=document.getElementById('compass'), ctxC=compass.getContext('2d');
  function drawCompass(){ const r=90;
    ctxC.clearRect(0,0,200,200);
    ctxC.beginPath(); ctxC.arc(100,100,r,0,2*Math.PI); ctxC.stroke();
    ctxC.beginPath(); ctxC.moveTo(100,100);
    ctxC.lineTo(100+windDir.x*r,100+windDir.y*r);
    ctxC.strokeStyle='red'; ctxC.stroke(); ctxC.strokeStyle='#000';
  }
  compass.addEventListener('mousemove',e=>{
    const rect=compass.getBoundingClientRect();
    const x=e.clientX-rect.left-100, y=e.clientY-rect.top-100;
    const len=Math.hypot(x,y);
    if(len>0){ windDir={x:x/len,y:y/len}; drawCompass(); }
  }); drawCompass();

  document.getElementById('windSpeed').oninput=e=>{
    windSpeed=+e.target.value;
    document.getElementById('windSpeedVal').innerText=windSpeed.toFixed(1);
  };
  document.getElementById('humidity-slider').oninput=e=>{
    humidity=+e.target.value;
    document.getElementById('humVal').innerText=humidity.toFixed(1);
  };
  document.getElementById('ignite').onclick=ignite;
  document.getElementById('reset').onclick=()=>{
    grid.forEach(row=>row.fill(EMPTY));
    offCtx.drawImage(mapImg,0,0,cols,rows);
    ignite();
  };
  </script>
</body>
</html>
